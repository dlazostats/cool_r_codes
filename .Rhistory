i=i+1
if(i>=Nmax){
break
}
}
# b) Secant Method
#=====================
secant_mthd<-function(a,b,tol,func,Nmax=500){
xn<-a - func(b)*(b-a)/(func(b)-func(a))
i=1
while(abs(xn-x1)>0){
a=b
b=xn
xn = func(b)*(b-a)/(func(b)-func(b))
i=i+1
if(i>=Nmax){
break
}
}
}
# b) Secant Method
#=====================
secant_mthd<-function(a,b,tol,func,Nmax=500){
xn<-a - func(b)*(b-a)/(func(b)-func(a))
i=1
while(abs(xn-x1)>0){
a=b
b=xn
xn = func(b)*(b-a)/(func(b)-func(b))
i=i+1
if(i>=Nmax){
break
}
}
return(xn)
}
func = function(x){
(x/2)^2-sin(x)
}
curve(func, xlim=c(1,3), col = 'red', lwd = 2, lty = 2, xlab = "x", ylab = "f(x)")
abline(h=0)
abline(v=0)
func = function(x){ (x/2)^2-sin(x) }
secant_mthd(1.5,2,0.0001,func)
# b) Secant Method
#=====================
secant_mthd<-function(x0,x1,tol,func,Nmax=500){
xn<-x1 - func(x1)*(x1-x0)/(func(x1)-func(x0))
i=1
while(abs(xn-x1)>0){
x0 <- x1
x1 <- xn
xn <- x1 + func(x1)*(x1-x0)/(func(x1)-func(x0))
i=i+1
if(i>=Nmax){
break
}
}
return(xn)
}
func = function(x){ (x/2)^2-sin(x) }
secant_mthd(1.5,2,0.0001,func)
# a) Bisection method
#=====================
bisec_mthd<-function(a,b,tol,func){
results <- data.frame(iteration = integer(),a = numeric(),
b = numeric(),m = numeric(),f_m = numeric())
iter<-1
while(abs(b-a)>=tol){
m=(a+b)/2
f_m<-func(m)
results <- rbind(results,data.frame(iteration = iter,a = a,b = b,m = m,f_m = f_m))
if(func(m)==0){
break
}else if (func(b)*f_m<0){
a<-m
}else{
b<-m
}
iter <- iter + 1
}
return(results)
}
bisec_mthd(1.5,2,0.001,func)
func = function(x){ (x/2)^2-sin(x) }
secant_mthd(1.5,2,0.0001,func)
xn<-x1 - func(x1)*(x1-x0)/(func(x1)-func(x0))
# b) Secant Method
#=====================
secant_mthd<-function(x0,x1,tol,func,Nmax=500){
xn<-x1 - func(x1)*(x1-x0)/(func(x1)-func(x0))
i=1
while(abs(xn-x1)>0){
x0 <- x1
x1 <- xn
xn <- x1 + func(x1)*(x1-x0)/(func(x1)-func(x0))
i=i+1
if(i>=Nmax){
break
}
}
return(xn)
}
func = function(x){ (x/2)^2-sin(x) }
secant_mthd(1.5,2,0.0001,func)
x0=1.5
x1=2
x2<-x1 - func(x1)*(x1-x0)/(func(x1)-func(x0))
x2
i=1
abs(x2-x1)>0
x0 <- x1
x1 <- x2
xn <- x1 + func(x1)*(x1-x0)/(func(x1)-func(x0))
x2 <- x1 + func(x1)*(x1-x0)/(func(x1)-func(x0))
x2
while(abs(x2-x1)>0){
x0 <- x1
x1 <- x2
x2 <- x1 + func(x1)*(x1-x0)/(func(x1)-func(x0))
i=i+1
if(i>=Nmax){
break
}
}
x2
i=1
Nmax=100
i=1
while(abs(x2-x1)>0){
x0 <- x1
x1 <- x2
x2 <- x1 + func(x1)*(x1-x0)/(func(x1)-func(x0))
i=i+1
if(i>=Nmax){
break
}
}
x2
secant_method <- function(f, x0, x1, tol = 1e-8, max_iter = 100) {
for (i in 1:max_iter) {
f_x0 <- f(x0)
f_x1 <- f(x1)
if (abs(f_x1 - f_x0) < .Machine$double.eps) {
stop("Denominator too small; division by near-zero.")
}
x2 <- x1 - f_x1 * (x1 - x0) / (f_x1 - f_x0)
if (abs(x2 - x1) < tol) {
return(list(root = x2, iterations = i, converged = TRUE))
}
x0 <- x1
x1 <- x2
}
return(list(root = x2, iterations = max_iter, converged = FALSE))
}
secant_method(func,1.5,2)
.Machine$double.eps
# b) Secant Method
#=====================
secant_mthd<-function(x0,x1,tol,func,Nmax=100){
for( i in 1:Nmax){
f_x0<-func(x0)
f_x1<-func(x1)
if(abs(f_x1-f_x0)<.Machine$double.eps){
stop("Denominator too small; division by near-zero.")
}
x2<-x1-f_x1*(x1-x0)/(f_x1 - f_x0)
if(abs(x2-x1)<tol){
return(list=c(root=x2,iterations=i,converged=TRUE))
}
x0<-x1
x1<-x2
}
return(list=c(root=x2,iterations=i,converged=FALSE))
}
func = function(x){ (x/2)^2-sin(x) }
secant_mthd(1.5,2,0.0001,func)
# b) Secant Method
#=====================
secant_mthd<-function(x0,x1,tol,func,Nmax=100){
for( i in 1:Nmax){
f_x0<-func(x0)
f_x1<-func(x1)
if(abs(f_x1-f_x0)<.Machine$double.eps){
stop("Denominator too small; division by near-zero.")
}
x2<-x1-f_x1*(x1-x0)/(f_x1 - f_x0)
if(abs(x2-x1)<tol){
return(list(root=x2,iterations=i,converged=TRUE))
}
x0<-x1
x1<-x2
}
return(list(root=x2,iterations=i,converged=FALSE))
}
func = function(x){ (x/2)^2-sin(x) }
secant_mthd(1.5,2,0.0001,func)
getwd()
head(dat)
# Statistical Prediction
#========================
# Sample - splitting
#---------------------
dat = read.table("http://www.stat.cmu.edu/~ryantibs/statcomp/data/xy.dat")
head(dat)
n<-nrow(dat)
set.seed(0)
set.seed(0)
inds<-sample(rep(1:2,length=nn))
inds<-sample(rep(1:2,length=n))
set.seed(0)
inds<-sample(rep(1:2,length=n))
table(inds)
dat.tr = dat[inds==1,] # Training data
dat.te = dat[inds==2,] # Test data
plot(dat$x, dat$y, pch=c(21,19)[inds], main="Sample-splitting")
legend("topleft", legend=c("Training","Test"), pch=c(21,19))
# Train on the first half
lm.1 = lm(y ~ x, data=dat.tr)
lm.10 = lm(y ~ poly(x,10), data=dat.tr)
# Predict on the second half, evaluate test error
pred.1 = predict(lm.1, data.frame(x=dat.te$x))
pred.10 = predict(lm.10, data.frame(x=dat.te$x))
# Predict on the second half, evaluate test error
pred.1 = predict(lm.1, data.frame(x=dat.te$x))
pred.10 = predict(lm.10, data.frame(x=dat.te$x))
test.err.1 = mean((dat.te$y - pred.1)^2)
test.err.10 = mean((dat.te$y - pred.10)^2)
test.err.1
test.err.10
# Plot the results
par(mfrow=c(1,2))
xx = seq(min(dat$x), max(dat$x), length=100)
plot(dat$x, dat$y, pch=c(21,19)[inds], main="Sample-splitting")
lines(xx, predict(lm.1, data.frame(x=xx)), col=2, lwd=2)
legend("topleft", legend=c("Training","Test"), pch=c(21,19))
text(0, -6, label=paste("Test error:", round(test.err.1,3)))
plot(dat$x, dat$y, pch=c(21,19)[inds], main="Sample-splitting")
lines(xx, predict(lm.10, data.frame(x=xx)), col=3, lwd=2)
legend("topleft", legend=c("Training","Test"), pch=c(21,19))
text(0, -6, label=paste("Test error:", round(test.err.10,3)))
# Split data in 5 parts, randomly
k = 5
set.seed(0)
inds = sample(rep(1:k, length=n))
head(inds, 10)
# Now run cross-validation: easiest with for loop, running over
# which part to leave out
pred.mat = matrix(0, n, 2) # Empty matrix to store predictions
i=1
cat(paste("Fold",i,"... "))
dat.tr = dat[inds!=i,] # Training data
dat.te = dat[inds==i,] # Test data
dat.tr
dat.te
inds!=i
inds[inds!=i]
# Train our models
lm.1.minus.i = lm(y ~ x, data=dat.tr)
lm.10.minus.i = lm(y ~ poly(x,10), data=dat.tr)
# Record predictions
pred.mat[inds==i,1] = predict(lm.1.minus.i, data.frame(x=dat.te$x))
pred.mat[inds==i,2] = predict(lm.10.minus.i, data.frame(x=dat.te$x))
# Now run cross-validation: easiest with for loop, running over
# which part to leave out
pred.mat = matrix(0, n, 2) # Empty matrix to store predictions
for (i in 1:k) {
cat(paste("Fold",i,"... "))
dat.tr = dat[inds!=i,] # Training data
dat.te = dat[inds==i,] # Test data
# Train our models
lm.1.minus.i = lm(y ~ x, data=dat.tr)
lm.10.minus.i = lm(y ~ poly(x,10), data=dat.tr)
# Record predictions
pred.mat[inds==i,1] = predict(lm.1.minus.i, data.frame(x=dat.te$x))
pred.mat[inds==i,2] = predict(lm.10.minus.i, data.frame(x=dat.te$x))
}
pred.mat
cv.errs = colMeans((pred.mat - dat$y)^2)
cv.errs
pred.mat
# Now run cross-validation: easiest with for loop, running over
# which part to leave out
pred.mat = matrix(0, n, 2) # Empty matrix to store predictions
i=1
cat(paste("Fold",i,"... "))
dat.tr = dat[inds!=i,] # Training data
dat.te = dat[inds==i,] # Test data
dat.tr
dat.te
# Train our models
lm.1.minus.i = lm(y ~ x, data=dat.tr)
lm.10.minus.i = lm(y ~ poly(x,10), data=dat.tr)
# Record predictions
pred.mat[inds==i,1] = predict(lm.1.minus.i, data.frame(x=dat.te$x))
pred.mat[inds==i,2] = predict(lm.10.minus.i, data.frame(x=dat.te$x))
pred.mat
pred.mat
pred.mat
# Now run cross-validation: easiest with for loop, running over
# which part to leave out
pred.mat = matrix(0, n, 2) # Empty matrix to store predictions
for (i in 1:k) {
cat(paste("Fold",i,"... "))
dat.tr = dat[inds!=i,] # Training data
dat.te = dat[inds==i,] # Test data
# Train our models
lm.1.minus.i = lm(y ~ x, data=dat.tr)
lm.10.minus.i = lm(y ~ poly(x,10), data=dat.tr)
# Record predictions
pred.mat[inds==i,1] = predict(lm.1.minus.i, data.frame(x=dat.te$x))
pred.mat[inds==i,2] = predict(lm.10.minus.i, data.frame(x=dat.te$x))
}
pred.mat
cv.errs = colMeans((pred.mat - dat$y)^2)
cv.errs
# Plot the results
par(mfrow=c(1,2))
xx = seq(min(dat$x), max(dat$x), length=100)
plot(dat$x, dat$y, pch=20, col=inds+1, main="Cross-validation")
lines(xx, predict(lm.1, data.frame(x=xx)), # Note: model trained on FULL data!
lwd=2, lty=2)
legend("topleft", legend=paste("Fold",1:k), pch=20, col=2:(k+1))
text(0, -6, label=paste("CV error:", round(cv.errs[1],3)))
plot(dat$x, dat$y, pch=20, col=inds+1, main="Cross-validation")
lines(xx, predict(lm.10, data.frame(x=xx)), # Note: model trained on FULL data!
lwd=2, lty=2)
legend("topleft", legend=paste("Fold",1:k), pch=20, col=2:(k+1))
text(0, -6, label=paste("CV error:", round(cv.errs[2],3)))
# Now we visualize the different models trained, one for each CV fold
for (i in 1:k) {
dat.tr = dat[inds!=i,] # Training data
dat.te = dat[inds==i,] # Test data
# Train our models
lm.1.minus.i = lm(y ~ x, data=dat.tr)
lm.10.minus.i = lm(y ~ poly(x,10), data=dat.tr)
# Plot fitted models
par(mfrow=c(1,2)); cols = c("red","gray")
plot(dat$x, dat$y, pch=20, col=cols[(inds!=i)+1], main=paste("Fold",i))
lines(xx, predict(lm.1.minus.i, data.frame(x=xx)), lwd=2, lty=2)
legend("topleft", legend=c(paste("Fold",i),"Other folds"), pch=20, col=cols)
text(0, -6, label=paste("Fold",i,"error:",
round(mean((dat.te$y - pred.mat[inds==i,1])^2),3)))
plot(dat$x, dat$y, pch=20, col=cols[(inds!=i)+1], main=paste("Fold",i))
lines(xx, predict(lm.10.minus.i, data.frame(x=xx)), lwd=2, lty=2)
legend("topleft", legend=c(paste("Fold",i),"Other folds"), pch=20, col=cols)
text(0, -6, label=paste("Fold",i,"error:",
round(mean((dat.te$y - pred.mat[inds==i,2])^2),3)))
}
rm(list=ls())
gc()
# Conformal Tidymodels
#----------------------
library(dplyr)
library(tidymodels)
#set working directory
setwd("C:/Users/dlazo\OneDrive - CORPORACIÓN ACEROS AREQUIPA SA/Escritorio/Diego/cool_r_codes")
#set working directory
setwd("C:/Users/dlazo\OneDrive - CORPORACIÓN ACEROS AREQUIPA SA/Escritorio/Diego/cool_r_codes")
#set working directory
setwd("C:/Users/dlazo/OneDrive - CORPORACIÓN ACEROS AREQUIPA SA/Escritorio/Diego/cool_r_codes")
# load data
dt0<-read.csv("train_qtb.csv")
dt0
dt1<-dt0 %>% select(RELACION,PE_MET:material_c)
dt1
# Conformal Tidymodels
#----------------------
library(dplyr)
library(tidymodels)
head(dt1)
# data split
split<-initial_split(dt1,strata=RELACION)
split
# data split
set.seed(1212)
dt1s<-dt1[sample(1:nrow(dt1),100),]
split<-initial_split(dt1s,strata=RELACION)
split
split<-initial_validation_split(dt1s,strata=RELACION)
dt1s<-dt1[sample(1:nrow(dt1),200),]
split<-initial_validation_split(dt1s,strata=RELACION)
split
train<-train(split)
train<-training(split)
test<-testing(split)
calib<-validation(split)
split
dim(calib)
# tidymodel and conformal
cv_folds<-vfold_cv(train,v=10,strata=RELACION)
cv_folds
svm_spec<-svm_rbf() %>%
set_mode("regression")
svm_flow<-workflow(RELACION~.,svm_spec)
svm_fit<-svm_flow %>% fit(data=train)
svm_fit
library(probably)
# conformal
conf_split<-int_conformal_split(svm_fit,cal_data=calib)
conf_split_test<-predict(conf_split,test,level=0.9) %>%
bind_cols(test)
conf_split_test
plot(test$RELACION,type="l")
plot(test$RELACION,type="l")
lines(conf_split_test$.pred_lower,col="red")
lines(conf_split_test$.pred_upper,col="red")
plot(test$RELACION,type="l",ylim=c(1.1,1.4))
lines(conf_split_test$.pred_lower,col="red")
lines(conf_split_test$.pred_upper,col="red")
conf_split_test<-predict(conf_split,test,level=0.9) %>%
bind_cols(test) %>%
mutate(cov=ifelse(RELACION<=.pred_upper & RELACION>=.pred_lower,1,0))
conf_split_test
conf_split_test %>% as.data.frame()
conf_split_test
mean(conf_split_test$cov)
n<-500
set.seed(1212)
dt1s<-dt1[sample(1:nrow(dt1),n),]
split<-initial_validation_split(dt1s,strata=RELACION)
train<-training(split)
test<-testing(split)
calib<-validation(split)
# tidymodel and conformal
cv_folds<-vfold_cv(train,v=10,strata=RELACION)
svm_spec<-svm_rbf() %>%
set_mode("regression")
svm_flow<-workflow(RELACION~.,svm_spec)
svm_fit<-svm_flow %>% fit(data=train)
# conformal
conf_split<-int_conformal_split(svm_fit,cal_data=calib)
conf_split_test<-predict(conf_split,test,level=0.9) %>%
bind_cols(test) %>%
mutate(cov=ifelse(RELACION<=.pred_upper & RELACION>=.pred_lower,1,0))
conf_split_test
mean(conf_split_test$cov)
plot(test$RELACION,type="l",ylim=c(1.1,1.4))
lines(conf_split_test$.pred_lower,col="red")
lines(conf_split_test$.pred_upper,col="red")
n<-500
set.seed(1211)
dt1s<-dt1[sample(1:nrow(dt1),n),]
split<-initial_validation_split(dt1s,strata=RELACION)
train<-training(split)
test<-testing(split)
calib<-validation(split)
# tidymodel and conformal
cv_folds<-vfold_cv(train,v=10,strata=RELACION)
svm_spec<-svm_rbf() %>%
set_mode("regression")
svm_flow<-workflow(RELACION~.,svm_spec)
svm_fit<-svm_flow %>% fit(data=train)
# conformal
conf_split<-int_conformal_split(svm_fit,cal_data=calib)
conf_split_test<-predict(conf_split,test,level=0.9) %>%
bind_cols(test) %>%
mutate(cov=ifelse(RELACION<=.pred_upper & RELACION>=.pred_lower,1,0))
conf_split_test
mean(conf_split_test$cov)
plot(test$RELACION,type="l",ylim=c(1.1,1.4))
lines(conf_split_test$.pred_lower,col="red")
lines(conf_split_test$.pred_upper,col="red")
#cv+inference
ctrl<-control_resamples(save_pred=T,extract=I)
ctrl
#cv+inference
ctrl<-control_resamples(save_pred=T,extract=I)
svm_resamp<-svm_flow %>%
fit_resamples(resamples = cv_fold,ctrl)
svm_resamp<-svm_flow %>%
fit_resamples(resamples = cv_fold,control=ctrl)
#cv+inference
ctrl<-control_resamples(save_pred=T,extract=I)
svm_resamp<-svm_flow %>%
fit_resamples(resamples = cv_folds,control=ctrl)
svm_resamp
conf_cv<-int_conformal_cv(svm_resamp)
mean(conf_split_test$cov)
conf_cv<-int_conformal_cv(svm_resamp)
conf_cv_test<-predict(conf_cv,test,level=0.9) %>%
bind_col(test)
conf_cv_test<-predict(conf_cv,test,level=0.9) %>%
bind_cols(test)
conf_cv_test
conf_cv_test<-predict(conf_cv,test,level=0.9) %>%
bind_cols(test)%>%
mutate(cov=ifelse(RELACION<=.pred_upper & RELACION>=.pred_lower,1,0))
mean(conf_cv_test$cov)
mean(conf_split_test$cov)
# Conformalized Quantile Regression
#-------------------------------------
set.seed(8181)
conf_qntl<-int_conformal_quantile(svm_fit,
train_data = train,
cal_data = calib,
level=0.9)
conf_qntl<-int_conformal_quantile(svm_fit,
train_data = train,
cal_data = calib,
level=0.9,
ntree=2000)
conf_qntl_test<-predict(conf_qntl,test) %>%
bind_cols(test) %>%
mutate(cov=ifelse(RELACION<=.pred_upper & RELACION>=.pred_lower,1,0))
mean(conf_qntl_test$cov)
plot(test$RELACION,type="l",ylim=c(1.1,1.4))
lines(conf_qntl_test$.pred_lower,col="red")
lines(conf_qntl_test$.pred_upper,col="red")
rm(list=ls())
gc()
shiny::runApp('C:/Users/dlazo/OneDrive - CORPORACIÓN ACEROS AREQUIPA SA/Escritorio/Diego/2025/dashboar 2pers-protec/app_terc_pro_new')
